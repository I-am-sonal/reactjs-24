React JS 04-01-2024 

React Latest version: 18.2.0 
pending tasks:
CORS issue without extension, website is not working and URL with API. - need to check

>>Day 1
notes for episode 1 to 9 starts

2. Namaste React Web Series code repositoryhttps://github.com/namastedev/namaste-react
3. NetflixGPT Project Github repository -
https://github.com/akshaymarch7/netflix-gpt
4. YouTube Project GitHub repository -
https://github.com/akshaymarch7/namaste-youtube

React CDN:
react library(code) is hosted and we can pull the data and use it from there into our local system.

CDN is not preffered way to add react into your project instead install it using npm.
version may get change and it will cause issue hence istall react package always in your app
=====================================================================================================

05-01-2024

Github installation



==========================================================================================================
06-01-2024

episode 2 - igniting our App

To ignite the app, we need to first make our code optimized before pushing it to production ready.

to make the react fast - React can make our App fast to some extent,
but lot of packages and libraries are required for it.

NPM - its a package manager for javascript. All the utilities and library code is inside npm package.

->npm init 
it will ask for the details and create package.json file in the directory.

Package.json -> is configuration for npm
it has details versions of the packages used in our program . it will be managed by npm.

bundler: webpack ,parcel, vite is same - collectively bundle the code together and push it to the production.
most imp package is bundler - to clean the code, optimized code, minifiled code

create-react-app uses webpack (babel) behind the scenes

we are going to use parcel as bundler in our project.

we have installed npm, now its easy to install parcel in app.

>> parcel installation:

npm install -D parcel //its required in development phase not on production hence, used -D

it will create all the modules that are required.

2 types of dependecies that app can have:
1) dev - used in development phase
2) Normal dependency - used in production

>>>>>>
carret in package.json
carret symbol uuper arrow is used for minor upgrade for eg 2.11.3 to 2.11.4 install that also (safe to use it will not affect the code)
tilt ~ symbol is used for major version updates

>>>>>
package-lock.json
keeps track of exact version that opackage is being installed

==========================================================================================================
07-01-2024

episode 2 - igniting our App

>>
node modules
inside node_modules folder - every module has its own dependecies inside it.
hence every dependecy has package.json file inside it.

it have too many data inside it , heavy data it should not be pushed to the production.
if we have package and package-lock with exact versions of dependecies we can delete the node modules folder
and recreate it using ->
npm install

package and package-lock these contains list of all the package details with versions that are required for the current project.
these files should be pushed to the github  

>>
igniting our app using parcel
npx parcel index.html // it will host the app onto the server as localhost:1234

npm -> installation
npx -> executing the package parcel

>>
install react
npm install react
npm install react-dom (or npm i react-dom , i is short form of install its the same)

now remove cdn packages and run ->
npx parcel index.html

and write import react and react-dom from react and import it from node_modules to use it in app.

add type="module" for the App.js script file added in index.html 

>>
if you wanted to build a bundle for the production
npx parcel build index.html // errror in package.json on line 5 remove code main: App.js"

whenver we write npx parcel index.html it generates dev build of your project and puts it into the dist folder.


browser data is shown using dist and parcel-cache folder which will automatically get generated once run the code.

>>
Mention name of the browser that your app should get compatible with :
check browserslist.dev

==========================================================================================================
08-01-2024

episode 3 - Laying the Foundation

package.json ->
add inside script to run the command
start -> dev
build -> used for production

"scripts": {
    "start": "parcel index.html", // command npm run start or npm start
    "build": "parcel build index.html" // command npm run build (** npm build wont work here)
  },


>>>>>>>>>>>>>>>
React element is not a HTML element its an object

React.createElement = object => HTMLElement(render)

>>>>>>>>>>>>>>>>>>

JSX:
we can write code in react without JSX but it makes dev life easier and its easy to understand the code using JSX

JsxHeading = <h1>Namaste React using JSX</h1>; //** its not HTML inside javascript (its HTML-like or XML-like syntax)


JSX is not pure javascript as javascript does not come with JSX inside it. JS engine understand ECMAScript language. (ES6)

Parcel is doing the job behind the scenes.

JSX -> traspiled(convert) the code (parcel) -> JS engine receives the code that browser can understand

parcel itself works as a manager and with the help of other libraries it will run the code.

parcel uses package Babel for it. Babel converts JSX into react element

>>>>
JSX -> (babel traspiles it to) React.createElement -> ReactElement JS object -> HTMLElement(render)

JSX Attributes -> should be in camelCase
className, tabIndex

-> JSX code in 1 line is okay
-> multiple lines - use round brackers () so that babel will understand that starting and end of the JSX code.

>>>>>>>>>>>>>>>>>>>>>
React Component can be created in 2 ways:

1) Class Based Components - OLD
2) Functional Component - New way

Functional Component - normal Function (or arrow Function )in js which returns some JSX.

Shorthand Syntax- If you have 1 line of code, you can skip "return" keyword in JSX.

>>>>>>>>>
react ele => const heading =();

react Component => const Heading =() => {};

to render a Functional Component => root.render(<HeadingComponent/>);

//code start => arrow function

const HeadingComponent = () => (
<h1>Namaste React Functional Component1</h1>
)
const HeadingComponent2 = () => (
    <div id="container">
        <HeadingComponent />
     <h2>Namaste React Functional Component2</h2>;
    </div>
)

root.render(<HeadingComponent2 />); // Component rendering
root.render(ele); // element rendering


//code end
==========================================================================================================
09-01-2024

episode 3 - Laying the Foundation
>>>>>>>>
***** Component Composition => Component inside Component

>>
Normal Functional Component - inside curly braces and "return" keyword

const HeadingComponent = function () {
  return(
<h1>Namaste React Functional Component1</h1>
)
};

>>>>
inside JSX if you use {} then you can write any js expression

>>>
How to add element inside JSX OR element inside element(variable)
const title = (
<h1>Namaste React Functional Component1</h1>
);

inside return add it as variable =>
(
  {title}
)

>>>>
malicious data:

if any malicious data is attacking through API, JSX will take care of it and it will escape and sanitize the data and pass it.
it prevents cross sites scripting attacks for you. Feel free to use any API in your code.

>>>>
function inside a function inside JSX using 3 ways:
{Title()}
<Title />
<Title></Title>

>>>>>>>>>>>>>>>>
Inline styling CSS:

return (
        <div className="res-card" style={{
            backgroundColor: "#f0f0f0"
        }}>
            <h3>Meghana Foods</h3>
        </div>
    )

we write 2 {} =>
1)first is to informing that its a js code
2)second {} is for object


>>>>>>>>>>>>>>>>>>>>>>
Props in React: Properties

Props - send dynamic data to the Component

props are arguments to a function

props is an object

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
destructing on the fly in props:
const RestaurantCard = ({resName, cuisine}) => { //imp -> its a destructing on the fly
    console.log(props);
    return (
      <h3>{props.resName}</h3>
            <h4>{cuisine}</h4>//instead of  <h4>{props.cuisine}</h4>
    )
}


OR--------------------
const RestaurantCard = (props) => { //imp
  const {resName, cuisine} = props; // imp
    console.log(props);
    return (
      <h3>{props.resName}</h3>
            <h4>{cuisine}</h4>//instead of  <h4>{props.cuisine}</h4>
    )
}
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
==========================================================================================================
10-01-2024

episode 3 - Laying the Foundation
Chrome extension: JSON viewer

Config Driven UI -
UI will get change depends on the configuration or data present in API. as per location the UI will be different.
Config comes from backend.

==========================================================================================================
10-01-2024

episode 4 - Talk is cheap, Show me the code

            <img className="res-log" alt="res-logo" src={"https://media-assets.swiggy.com/swiggy/image/upload/fl_lossy,f_auto,q_auto,w_660/" + resData.info.cloudinaryImageId}/>

>>>>>>>>>>>>
Optional Chaining (?)

    const {cloudinaryImageId, name, areaName, cuisines, sla} = resData?.info;


>>>>>>>>

map() function:

            <div className="res-container">
 {
                    resList.map((restaurant) => (
                        <RestaurantCard key={restaurant.info.id} resData={restaurant} />
                    ))
                }
            </div>


>>>>>>>

==========================================================================================================
11-01-2024

episode 4 - Talk is cheap, Show me the code

Warning: Each child in a list should have a unique "key" prop.

why to use key?
if any new item needs to add in the card, react would not know where the card has been added, 
hence it will rerender all the on the browser, it will not be able to uniquely identify the newly added data.
if we have unique ids like id1, id2, id3, id4 for each cart, 
then it will add new item as idnew and render only that item on the browser and not all the existing items.
if we have more than 100 items, then its a bad practice and will take too much time to render if no unique ids are given.

index -> 
******** but react itself says never use index as key because if the order of the items may get change.

you can use index as 2nd property of map for uniquely identify each items starting from 0 to n.

<div className="res-container">
                {
                    resList.map((restaurant, index) => (
                        <RestaurantCard key={index} resData={restaurant} />
                    ))
                }
            </div>

******** but react itself says never use index as key
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
********** Not using keys is not acceptable <<<<<<<<index as key <<<<<<<< unique id (best practice)

==========================================================================================================
12-01-2024

Episode-05 | Let's Get Hooked

Best way as per industry practice: 
file extension:
header.js/heade.tsx/header.jsx - we prefer to write header.js

import Header from "./Components/Header"; - file extension .js is not required, React will treat it as Js file only.

>>>>>>>>>>>>>>>
Never keep hardcoded data into the Components folder.
keep it inside common file-> constant.js, config.js, utils.js or inside common folder.

Best way - make "utils" folder and keep all utilities related files inside it.
constant.js - "c" is small as its a folder not a Component
Keep all the URLs labels in capital letters

>>>>>>>>>>>>>>>>>>>>>>>
Normal export in file:=>

1) default export/import
export default resList;
import Component from "path";

2) named export/import 
export const Component;

named import: 
import {Component or variable name} from "./../../file path"; // curly braces are imp

- when you need to export multiple things.
export default functn 1; // we cannot do this twice in a single file.
export default functn 2: // we cannot do this twice in a single file.


==========================================================================================================
16-01-2024

Episode-05 | Let's Get Hooked

React is fast -
it has efficient DOM Manipulation, virtual DOM is greatly handled by React.
it finds out the difference between actual DOM and virtual DOM in UI. it has DIff Algorithm. 
this is core of react.



Normal Js variable:

//Normal JS variable
let ListOfRestaurants = [
	{
	"info": {
		"id": "239077",
    }
    }
]

//state variable - Super powerful variable

for that we use React Hooks to manage the state of the variable

React Hooks -
normal javascript Function GIVEN BY React
ITS A utility function written by React from node_modules
There are multiple functions in react:
2 main hooks in React:
useState() - super powerful state variables in react, use as named import {useState}
useEffect()

useState():
Normal variable:
let ListOfRestaurants = [];

//local state variable useState() variable:
const [ListOfRestaurants] = useState([]); //empty data using useState

let ListOfRestaurants = []; //empty data using normal js variable

////////////////////////////////////////////////////////
Normal JS variable:

// let ListOfRestaurants = [
// 	{
// 	"info": {
// 		"id": "239077",
// 		"name": "McDonald's",
// 		"cloudinaryImageId": "bb7ae131544c7d37e10fc5faf76f09d6",
// 		"locality": "Kohinoor corne",
// 		"areaName": "Prabhadevi",
// 		"cost": "₹400",
// 			"cuisines": [
// 		  "Burgers",
// 		  "Beverages",
// 		  "Cafe",
// 		  "Desserts"
// 		],
// 		"avgRatingString": "4",
// 		  "deliveryTime": 24,
// 		  "slaString": "24 mins",
// 	  },
//     },
// 	{
// 		"info": {
// 			"id": "239078",
// 			"name": "KFC",
// 			"cloudinaryImageId": "bb7ae131544c7d37e10fc5faf76f09d6",
// 			"locality": "Kohinoor corne",
// 			"areaName": "Worli",
// 			"cost": "₹1000",
// 				"cuisines": [
// 			  "Burgers",
// 			  "Beverages",
// 			  "Cafe",
// 			  "Desserts"
// 			],
// 			"avgRatingString": "5.5",
// 			  "deliveryTime": 20,
// 			  "slaString": "20 mins",
// 		  },
// 	},
// 	{
// 		"info": {
// 			"id": "239079",
// 			"name": "McD",
// 			"cloudinaryImageId": "bb7ae131544c7d37e10fc5faf76f09d6",
// 			"locality": "Kohinoor corne",
// 			"areaName": "Worli",
// 			"cost": "₹1000",
// 				"cuisines": [
// 			  "Burgers",
// 			  "Beverages",
// 			  "Cafe",
// 			  "Desserts"
// 			],
// 			"avgRatingString": "4.1",
// 			  "deliveryTime": 20,
// 			  "slaString": "20 mins",
// 		  },
// 		}		
// ];

--------------------------
js variable using useState():
const [ListOfRestaurants, setListOfRestaurants] = useState([
		{
				"info": {
					"id": "239077",
					"name": "McDonald's",
					"cloudinaryImageId": "bb7ae131544c7d37e10fc5faf76f09d6",
					"locality": "Kohinoor corne",
					"areaName": "Prabhadevi",
					"cost": "₹400",
						"cuisines": [
					  "Burgers",
					  "Beverages",
					  "Cafe",
					  "Desserts"
					],
					"avgRatingString": "4",
					  "deliveryTime": 24,
					  "slaString": "24 mins",
				  },
			    },
				{
					"info": {
						"id": "239078",
						"name": "KFC",
						"cloudinaryImageId": "bb7ae131544c7d37e10fc5faf76f09d6",
						"locality": "Kohinoor corne",
						"areaName": "Worli",
						"cost": "₹1000",
							"cuisines": [
						  "Burgers",
						  "Beverages",
						  "Cafe",
						  "Desserts"
						],
						"avgRatingString": "5.5",
						  "deliveryTime": 20,
						  "slaString": "20 mins",
					  },
				},
				{
					"info": {
						"id": "239079",
						"name": "McD",
						"cloudinaryImageId": "bb7ae131544c7d37e10fc5faf76f09d6",
						"locality": "Kohinoor corne",
						"areaName": "Worli",
						"cost": "₹1000",
							"cuisines": [
						  "Burgers",
						  "Beverages",
						  "Cafe",
						  "Desserts"
						],
						"avgRatingString": "4.1",
						  "deliveryTime": 20,
						  "slaString": "20 mins",
					  },
					}	
	]);


if we wants to make our data empty:
setListOfRestaurants([]);
    -------------------------------------------------------------------------

    examples:
    const list = [];
    list.push("abc", "xyz");

    or 
    let list = []; //let is used so we can update the variable data.
    list = ["abc", "xyz"];
-------------------------------------------------------------------------

whenver a state variable updates, react rerenders the Component

Reconciliation Algorithm(React Fiber):in React 16 came

suppose we have a res-container. inside that we have 
7 res cards -> (updates / changes to) -> 3 filtered cards

react creates -> virtual DOM for it.

virtual DOM (representation of actual DOm which has obj and not actual tags (js obj)) 
=> is not a actual DOM (actual tags <div> <h1>)

////////////////////

Diff Algorithm:
finds the difference between the previous virtual DOM and the updated virtual DOM


-----------------------------------------------
destructing

const [ListOfRestaurants, setListOfRestaurants] = useState([]); // same as given below

OR

const arr = useState([]);
const [ListOfRestaurants, setListOfRestaurants] = arr;

here:
const ListOfRestaurants = arr[0];
const setListOfRestaurants = arr[1];


==========================================================================================================
16-01-2024

Episode-06 | Exploring the World

Monolith Architechture:

earlier projects we have everything in 1 single project:
API, UI, Authentication, DBMS connectivity, SMS service

Monolith Architechture -if we want to change simple color of a button , we need to deploy entire project again.

------------------------------------------

Microservice Architechture:
we have different services for different jobs.
All these services combine together and form a big App.

these diff project concept is known as "separation of concerns" and "single responsibility principle".
all team members works on diff service and diff individual repository.
All these services run on their own specific port.

port 1234 - ui service
port 1000 - backend service

all these services can mapped to domain name

url/ - for ui
url/backend
url/sms

they call eachother using port and urls and connect.

==========================================================================================================
17-01-2024

Episode-06 | Exploring the World

How React application interact/connect with outside world?

How webApps or UI fetch the data from backend?
2 approches:
1) Page loads -> API call -> wait for data to come -> UI renders(500 ms)

2) Page loads -> UI renders with Shimmer UI -> API call (react approch -> better UX)
in this approch atleast we see skeleton of the page and no need to wait for api call to fetch the entire data
and then show the page after 500-600ms. it will not freeze the page.

react render cycles are very fast.

-------------------------------------
useEffect Hook:

Hook is normal js function which react gives us which has its own use case. 

useEffect(()=> {}, []); // callback function is called after your Component renders.

fetch() -> this function is given by browser which JS engine have.

example:

useEffect(() => {
		fetchData();
	}, []);

	const fetchData = async () => {
		const data = await fetch("https://www.swiggy.com/dapi/restaurants/list/v5?lat=19.006288730947983&lng=72.81481426209211&is-seo-homepage-enabled=true&page_type=DESKTOP_WEB_LISTING");
		const json = await data.json();
		console.log(json);
	}


==========================================================================================================
18-01-2024

Episode-06 | Exploring the World

How to fetch data using API:

const Body = () => {

	const [ListOfRestaurants, setListOfRestaurants] = useState([]);

	useEffect(() => {
		fetchData();
	}, []);

	const fetchData = async () => {
		const data = await fetch("https://www.swiggy.com/dapi/restaurants/list/v5?lat=19.006288730947983&lng=72.81481426209211&is-seo-homepage-enabled=true&page_type=DESKTOP_WEB_LISTING");
		const json = await data.json();
		console.log(json);
		// console.log(json.data.cards[4].card.card.gridElements.infoWithStyle.restaurants);
		setListOfRestaurants(json?.data?.cards[4]?.card?.card?.gridElements?.infoWithStyle?.restaurants);
	}

	// let ListOfRestaurants = [];

//Normal JS variable
// let ListOfRestaurants = [
// 	{
// 	"info": {
// 		"id": "239077",
// 		"name": "McDonald's",
// 		"cloudinaryImageId": "bb7ae131544c7d37e10fc5faf76f09d6",
// 		"locality": "Kohinoor corne",
// 		"areaName": "Prabhadevi",
// 		"cost": "₹400",
// 			"cuisines": [
// 		  "Burgers",
// 		  "Beverages",
// 		  "Cafe",
// 		  "Desserts"
// 		],
// 		"avgRatingString": "4",
// 		  "deliveryTime": 24,
// 		  "slaString": "24 mins",
// 	  },
//     },
// 	{
// 		"info": {
// 			"id": "239078",
// 			"name": "KFC",
// 			"cloudinaryImageId": "bb7ae131544c7d37e10fc5faf76f09d6",
// 			"locality": "Kohinoor corne",
// 			"areaName": "Worli",
// 			"cost": "₹1000",
// 				"cuisines": [
// 			  "Burgers",
// 			  "Beverages",
// 			  "Cafe",
// 			  "Desserts"
// 			],
// 			"avgRatingString": "5.5",
// 			  "deliveryTime": 20,
// 			  "slaString": "20 mins",
// 		  },
// 	},
// 	{
// 		"info": {
// 			"id": "239079",
// 			"name": "McD",
// 			"cloudinaryImageId": "bb7ae131544c7d37e10fc5faf76f09d6",
// 			"locality": "Kohinoor corne",
// 			"areaName": "Worli",
// 			"cost": "₹1000",
// 				"cuisines": [
// 			  "Burgers",
// 			  "Beverages",
// 			  "Cafe",
// 			  "Desserts"
// 			],
// 			"avgRatingString": "4.1",
// 			  "deliveryTime": 20,
// 			  "slaString": "20 mins",
// 		  },
// 		}		
// ];


	return (
		<div className="body"> 
			<div className="filter">
				<button className="filter-btn" onClick={()=> {
					const FilteredList = ListOfRestaurants.filter(res => res.avgRating > 4)
					console.log(ListOfRestaurants);
					setListOfRestaurants(FilteredList);
				}}>Top Rated Restaurants</button>
			</div>
			<div className="res-container">
				{
					ListOfRestaurants.map((restaurant) => (
						<RestaurantCard key={restaurant.id} resData={restaurant} />
					))
				}
			</div>
		</div>
	)
}

-------------------------------------------------------------------------------------------


Optional Chaining:
? is used for it:
		setListOfRestaurants(json?.data?.cards[4]?.card?.card?.gridElements?.infoWithStyle?.restaurants);


---------------------------------------

What does useEffect do? 

By using this Hook, you tell React that your component needs to do something after render. React will remember the function you passed (we’ll refer to it as our “effect”), and call it later after performing the DOM updates. In this effect, we set the document title, 
but we could also perform data fetching or call some other imperative API.

------------------------------------------

Shimmer UI?

A shimmer UI is a version of the UI that doesn't contain actual content, 
but instead mimics the layout and shapes of the content that will eventually appear. 
It uses a gradient animation that creates a shimmering effect over the placeholders, 
giving the user a sense of motion and progress.

==========================================================================================================
23-01-2024

Episode-06 | Exploring the World

why use useState:

to change the value or to make it dynamic and update the UI on the page we would require useState,
the normal JS would not be able to update the UI on the page in react, hence use useState.
useState udates that perticular react component and refresh the entire data (not only changed variable 
but also the entire component (and not the other components) on the page )and show it on the UI of the page.

---------------------------------------------------------------------------

important:
whenver state variables update, react triggers a Reconciliation cycle (rerenders the component)
efficient rendering and fast rendering
it rerenders the whole component but update only the perticular tag or change that has happened.
because it will check the older version of virtual DOM and newer version of virtual DOM and 
update only the input change that has happened.

==========================================================================================================
25-01-2024

Episode-06 | Exploring the World

to check exact name:

<button className="searchBtn" onClick={() => {
						const FilteredRestaurant = ListOfRestaurants.filter((res) => 
						res.info.name === searchText);
						setListOfRestaurants(FilteredRestaurant);
					}}>Search</button>

to check a word that includes in a name: we will make it case insensitive
<button className="searchBtn" onClick={() => {
						const FilteredRestaurant = ListOfRestaurants.filter((res) => 
						res.info.name.toLowerCase().includes(searchText.toLowerCase()));
						setListOfRestaurants(FilteredRestaurant);
					}}>Search</button>

---------------------------------------------------------------------------

CORS :
when you are trying to make an API call from one domain to other 
e.g. from localhost to swiggy.com API, browser does not allow it. so to bypass the CORS, we have
corsproxy.io 
append "https://corsproxy.io/?" before API URL

currently I have added "https://proxy.cors.sh/" before the URL

const data = await fetch("https://proxy.cors.sh/https://www.swiggy.com/dapi/restaurants/list/v5?lat=19.006288730947983&lng=72.81481426209211&is-seo-homepage-enabled=true&page_type=DESKTOP_WEB_LISTING");


==========================================================================================================
25-01-2024

Episode-07 | Finding the Path

Routing Library:
----------------------------------------------------------------------
useEffect:

how useEffect hook called:
import { useEffect, useState } from "react";

useEffect(() => {
		fetchData();
	}, []);

1st arguments -> callback function
2nd arguments -> dependecy array (Optional to use, if we dont use this, useEffect will render every time when 
component renders)

useEffect is called after every render component
dependency array changes the behaviour, and its not mandatory

if no dependency array => useEffect will called on every render
if dependency array is empty = [] => useEffect will be called on initial render(just once),
when the Component is render for the first time
if dependency array is = [btnNameReact] => useEffect is called every time when btnNameReact is updated.
(if we pass something inside dependency array, then it will only be called once the dependency changes/updates.)
---------------------------------------------------------------------

useState:

=> never use useState outside your component.
=> it is used to create local variables inside functional components.
=> always try to write useState on the top of the function at the start, to avoid inconsistency.
=> never use hook inside if else conditions or for loop or inside another nested function

==========================================================================================================
26-01-2024

Episode-06 | Exploring the World

React Library - React Router DOM - installation
=> npm i react-router-dom

for creating routing , go to root level component -> App.js
-> we have to create routing configuration inside it

1)import { createBrowserRouter } from "react-router-dom";

2)configuration: its a list , array of objects that define the path and what should happen on that path:

const appRouter = createBrowserRouter([
    {
        path: "/",
        element: <AppLayout />,
    },
    {
        path: "/about",
        element: <About />,
    },
]);

3) We need to provide this configuration to render function.

import RouterProvider - it provides routing configuration to our app.

earlier we write - root.render(<AppLayout />);

now - root.render(<RouterProvider router={appRouter} />);

---------------------------------------------------------------------------------
Routers:
Picking a Router 🆕
createBrowserRouter 🆕 - This is the recommended router for all React Router web projects. 
It uses the DOM History API to update the URL and manage the history stack. (if you wants to do simple routing)
createHashRouter 🆕
createMemoryRouter 🆕
createStaticHandler 🆕
createStaticRouter 🆕
RouterProvider 🆕
StaticRouterProvider 🆕


----------------------------------------------------------------------------------------------------
To show error page for random URLs: 
use errorElement

const appRouter = createBrowserRouter([
    {
        path: "/",
        element: <AppLayout />,
        errorElement: <Error />,
    },
])
---
react-router-dom give access to 1 important hook to handle the error :useRouteError

it will give more information about the error.

import { useRouteError } from "react-router-dom"; // **** function starting with "use" is a hook

----------------------------------------------------------------------------------------------------
Children routing:

using Outlet:
import { createBrowserRouter, RouterProvider, Outlet } from "react-router-dom";

const AppLayout = () => {
    return (
        <div className="app">
            <Header />
            <Outlet />
        </div>
    )
}

Outlet is in the AppLayout. this Outlet will be filled with the Children according to the path on what page we are.

when we are on "/", <body /> will be filled in the Outlet. and so on.
according to the route it will get render.
----------------------------------------------------------------------------------------------------
single page application - 1 page - different components

how to link pages to the anchor in navigation: 

Never use a anchor tag <a></a> if you want to route a page to a link.
because the whole page will get refreshed and page will get reloaded.

link component - superpower given by react-router-dom
import { Link } from "react-router-dom";

how to use:
instead of : <li><a href="/about">About Us</a></li>
use:         <li><Link to="/about">About Us</Link></li>

it fetches the data and does not reload the page. it only refreshes the component where the changes happened.
its called as single page application
----------------------------------------------------------------------------------------------------
2 types of routing in web application:
1) Client side routing - here, we already have all pages components data inside App.js,
 it does not make any network call. (single page application)
2) server side routing -
when we click on a about page link, it reload the whole page, it sends the network call to about us page,
fetches that html and render on to the page.

----------------------------------------------------------------------------------------------------
27-01-2024

Episode-07 | Finding the Path

Dynamic Routing:

using colon ":" to puth dynamic path of the page.

{
                path: "/restaurants/:resId",
                element: <RestaurantMenu />
            }

:resId is dynamic
----------------------------------------------------------------------------------------------------
to use API data 
first store the APi data into the json. then use state variable and use it to show on the page.
it will automatically update the UI.

----------------------------------------------------------------------------------------------------
params:
import { useParams } from "react-router-dom";

to get the id react gives us the inbuild hook

----------------------------------------------------------------------------------------------------
on click of the list menu, user should get redirected to that menu details page:

key should be added to the parent jsx

----------------------------------------------------------------------------------------------------
<Link>
behind the scenes Link is using anchor tag <a> in React.
LInk is wrapper over the anchor tag. it will not get page reloaded
and to understand the browser react will make it anchor for html rendering that browser understand.

==========================================================================================================
28-01-2024

Episode-08 | Let's Get Classy

React life cycle working:

**Class based components: 
-> OLder way of writting a component
-> its a normal js class
-> extents React.Component -> so that react will know that its a class based component
->React.Component is a class and the className which we create it extents its Properties given by React
-> hence we need to import react from react at the top.
-> here, it will have render method which will return a JSX expression
-> props - constructor(props) and super(props) and will receives it using "tihs.props.name" in JSX. it 
can be accessed anywhere in the class using "this" keyword.
->no hooks for state
-> this.state is a whole object that contains all the state variables of the component


**functional component:
-> normal js function 
-> function which returns a jsx expression
-> export is same in both the components
-> way of passing the props is same
-> props - function will receives it as an argument.
-> we use hooks to change the state of the variables.
---------------------------------------------------------------------
const About = () => {
    return (
        <div>
            <h1>About Page</h1>
            <User name={"Sonal Bajage functional"}/>
            <UserClass name={"Sonal Bajage class"}/>
        </div>
    )
}
---------------------------------------------------------------------
example functional component:

const User = ({name}) => {
    return (
        <div className="user-card">
            <h2>Name: {name}</h2>
            <h3>Location: Mumbai</h3>
            <h4>Contact: sb@gmail.com</h4>
        </div>
    )
}

export default User;
---------------------------------------------------------------------
example class component:

import React from "react";

class UserClass extends React.Component {

    constructor(props){
        super(props);
        console.log(props);
    }

    render() {
        return (
            <div className="user-card">
                <h2>Name: {this.props.name}</h2>
                <h3>Location: Mumbai</h3>
                <h4>Contact: sb@gmail.com</h4>
            </div>
        );
    }
}

export default UserClass;

==========================================================================================================
29-01-2024

Episode-08 | Let's Get Classy

constructor and super(props) in React:

Super() in React component
Super() function is to call the constructor of the parent class. It is used when we need to access a few variables in the parent class. It returns an object which represents the parent class. The right way to use it is when the child class and parent class are from the same field. To put it simply, it refers to the immediate parent class instance variable, in the above example, which is also the base class for the Person component. So when we pass props to super, the props get assigned to this.

index.js

import React from "react";
import { render } from "react-dom";
import Children from "./Children";
class Main extends React.Component {
constructor(props) {
super();
}


render() {
return <Children />;
}
}


render(<Main />, document.getElementById("root"));

Children.js

import React from "react";
import { render } from "react-dom";

export default class Children extends React.Component {
constructor(props) {
super();
this.state = { name: "Test" };
}


render() {
return <h2>{this.state.name}</h2>;
}
}

Here, we have Main and Children components with state and props. As you can see, it extends 'React.Component' with the 'super()' method. A component that extends 'React.Component' must call the 'super()' constructor in the derived class since it’s required to access this context inside the derived class constructor.

---------------------------------------------------------------------
destructing:

import { useState } from "react";

const User = ({name}) => {

    const [count] = useState(0);
    return (
        <div className="user-card">
            <h1>Count: {count}</h1>
            <h2>Name: {name}</h2>
            <h3>Location: Mumbai</h3>
            <h4>Contact: sb@gmail.com</h4>
        </div>
    )
}

export default User;
-----------
	to:

	import React from "react";

class UserClass extends React.Component {

    constructor(props){
        super(props);
        console.log(props);

        this.state = {
            count: 0,
        }
    }


    render() {
        const {name, location} = this.props;
        const {count} = this.state;

        return (
            <div className="user-card">
                <h1>Count: {count}</h1>
                <h2>Name: {name}</h2>
                <h3>Location: {location}</h3>
                <h4>Contact: sb@gmail.com</h4>
            </div>
        );
    }
}

export default UserClass;

	---------------------------------------------------------------------
	functional component - we load/mount//render/execute/call/invoke it and show it onto the webpage.

	in class based component
	state variables in class based component:

	*******loading a class based component = creating instance of a class
	constructor is best place to pass the props and to create the state variables


***Never update state variables directly.

---------------------------------------------------------------------
count increment example using functional component:

import { useState } from "react";

const User = ({name}) => {

    const [count, setCount] = useState(0);
    const [count2] = useState(1);

   

    return (
        <div className="user-card">
            <h1>Count: {count}</h1>
            <button onClick={() => {
                 setCount(count + 1)
            }}>Count Increse Functional</button>
            <h4>Count: {count2}</h4>
            <h2>Name: {name}</h2>
            <h3>Location: Mumbai</h3>
            <h4>Contact: sb@gmail.com</h4>
        </div>
    )
}

export default User;
---------------------------------------------------------------------
count increment example using class based component:

import React from "react";

class UserClass extends React.Component {

    constructor(props){
        super(props);
        console.log(props);

        this.state = {
            count: 0,
            count2: 2,
        }
    }


    render() {
        const {name, location} = this.props;
        const {count, count2} = this.state;

        return (
            <div className="user-card">
                <h1>Count: {count}</h1>
                <button onClick={() => {
                     this.setState({
                        count: this.state.count + 1,
                        count2: this.state.count2 + 1,

                    })
                }
                   
                }>Count Increase</button>
                <h4>Count: {count2}</h4>
                <h2>Name: {name}</h2>
                <h3>Location: {location}</h3>
                <h4>Contact: sb@gmail.com</h4>
            </div>
        );
    }
}

export default UserClass;

==========================================================================================================
30-01-2024

Episode-08 | Let's Get Classy

Lifecycle methods of class component:

loading the page onto the website = mounting the page

about us component gets mount/call line by line. once it checks that there is class based component,
it will starts to load UserClass component now.
the new instance of this class component is called/ or this class gets instantiated.
first, constructor is called, then render is called

then rendering will be done as:
parent constructor, parent render then child constructor and child render

componentDidMount() - first, constructor is called, then render is called and once this class based component is placed onto the DOM,
componentDidMount() gets called.
this is the mounting cycle

componentDidMount() behaviour with parent and child class:
first parent constructor then render , it checks in render the child component and triggers it.
childs constructor called then render and then componentDidMount of child and once the child mounting is done
properly then componentDidMount of parent will be called.

rendering of Lifecycle methods:

-Parent Constructor
-Parent Render
    -Child Constructor
    -Child Render
    -Child componentDidMount
-Parent componentDidMount

if we have 2 different instances of child component:
Parent Constructor
 Parent Render
     1st childChild Constructor
     1st Render
     2nd childChild Constructor
     2nd Render

    <2 virtual DOM's diff is calculated and its Updated/Manipulation - In single batch,
    it will optimize the performance of the React App>
     1st childChild componentDidMount
     2nd childChild componentDidMount
 Parent componentDidMount
------------------------------------------------------------------------
Why to use componentDidMount?

when we want to do things which needs to be done after render()
i.e. use case - API calls


------------------------------------------------------------------------
import React from "react";

class About extends React.Component{
}

same as =
destructing

import {Component} from "react";

class About extends Component{
}
------------------------------------------------------------------------
React lifecycle methods diagram:

https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

render phase is fast
commit phase takes time as it contains DOM Manipulation/updating, its expensive

API calling in class based component:

import React from "react";
import { json } from "react-router-dom";

class UserClass extends React.Component {

    constructor(props){
        super(props);
        // console.log(props);

        this.state = {
            count: 0,
            count2: 2,
            userInfo:{
                id: "0",
                login: "Default",
            }
        }
        //console.log(this.props.name + "Child Constructor");

    }

    async componentDidMount(){
        //console.log(this.props.name +"Child componentDidMount");

        const data = await fetch("https://api.github.com/users/I-am-sonal");
        const json = await data.json();
        console.log(json);

        this.setState({
            userInfo: json,
        })
    }
    render() {

        // const {name, location} = this.props;
        const {count, count2} = this.state;
        const {id, login, avatar_url} = this.state.userInfo;

        //console.log(this.props.name +"Child Render");

        return (
            <div className="user-card">
                <h1>Count: {count}</h1>
                <button onClick={() => {
                     this.setState({
                        count: this.state.count + 1,
                        count2: this.state.count2 + 1,

                    })
                }
                   
                }>Count Increase</button>
                <h4>Count: {count2}</h4>
                <img src={this.state.userInfo.avatar_url}/>
                <h2>ID: {this.state.userInfo.id}</h2>
                <h3>Login: {this.state.userInfo.login}</h3>
            </div>
        );
    }
}

export default UserClass;
----------------------------------

***********************
---------------React mounting lifecycle:

Constructor (Dummy data)
Render (Dummy data)
<html Dummy>
componentDidMount
<API call>
<this.setState> -> state variable is updated


***********************
---------------React update lifecycle:
render (API call with new values)
HTML (new API data)
componentDidUpdate

    <2 virtual DOM's diff is calculated and its Updated/Manipulation - In single batch,
    it will optimize the performance of the React App>
     1st childChild componentDidMount
     2nd childChild componentDidMount
 Parent componentDidMount

 -------

React will render the DOM with Dummy data first,
this.state = {
            count: 0,
            count2: 2,
            userInfo:{
                id: "0",
                login: "Default",
            }
        }


so that users sees something on the page with Dummy details and we can use shimmer for better UI.

when we use setState -> updating phase starts
when setState has updated info, React triggers the renders function once again. 
this time render will have udpated info in it.
DOM is updated with new values
componentDidUpdate called - it will be called at the end.

***********************
---------------React unmount lifecycle:
    componentWillUnmount(){
        console.log("componentWillUnmount");
    }
  when component disappear from the HTML web page.  
  removing from the UI.
  check once user clicks on the the new page.
  when user leaves the component, lot of things needs to be clear
  (not page because its spa(single page application)).
-------------------------------

  when to use componentWillUnmount:
  when we use setInterval for 1 sec, and try to change the page , it will still run and will not stop.
  when we click 2nd time on second page, setInterval will set the time with 2 sec.
  -because its not changing the page, its reloading the components.
  - Reconciliation is hapening.
  - performance will get slow at some point.

  example class based component:
async componentDidMount(){

        this.timer = setInterval(() => {
            console.log("namaste react operation!");
        }, 1000);
}

        componentWillUnmount(){
        clearInterval(this.timer);
        console.log("componentWillUnmount");
    }


-----this will stop the timer.
***********************
example functional component:

useEffect(()=>{
        const timer = setInterval(() => {
            console.log("namaste react operation!");
        }, 1000);
        
        console.log("useEffect");

        return ()=> {
            clearInterval(timer);
            console.log("useEffect return");
    
        }
    },[]);
    
    console.log("render");

    ******************************************************

  Currently in latest version this has been simplified a lot.

  example:

  useEffect(()=>{
        // setInterval(() => {
        //     console.log("namaste react operation!");
        // }, 1000);
        
        console.log("useEffect");

        return ()=> {
            // to unmount
            console.log("useEffect return");
    
        }
    },[]);
    
    console.log("render");

    here, rendering will be done as:
    render will be called
    useEffect will be called
    useEffect return will be called. -> once you leave that page(component)
    
    --------------------------------------------------------------------------------------------------------
    ****Never compaire React lifecycle method to functional component 
    its a new way altogether
3 stages:
1)mounting/rendering/calling
2)updating
3)unmounting
    --------------------------------------------------------------------------------------------------------
    example of componentDidUpdate

    componentDidUpdate(prevProps, prevState){
        if(this.state.count != prevState.count || this.state.count2 != prevState.count2){
            //do something
        }
    }

    in latest React version:

    useEffect(()=> {
        console.log("useEffect renders");

    },[count, count2]); -> because multiple state variable, hence array is there

------------------------------if we have 2 use cases, 1 for count and another different use case for count2:
useEffect(()=> {
        console.log("useEffect renders case 1");

    },[count]);


    useEffect(()=> {
        console.log("useEffect renders case 2");

    },[count2]);

==========================================================================================================
notes for episode 1 to 9 ends

